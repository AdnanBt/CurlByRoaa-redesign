<style>
/* Reset and Base */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Section */
.featured-collections-section {
  padding: 60px 20px;
  background: #FAF8F6;
  position: relative;
  overflow: hidden;
}

.featured-collections-header {
  text-align: center;
  margin-bottom: 40px;
}

.featured-collections-title {
  font-size: clamp(2rem, 3vw, 2.8rem);
  font-weight: 700;
  color: #2d2d2d;
  margin-bottom: 12px;
}

.featured-collections-description {
  font-size: 1.1rem;
  color: #666;
  max-width: 700px;
  margin: 0 auto;
}

/* Carousel Container */
.featured-collections-carousel {
  max-width: 1400px;
  margin: 0 auto;
  position: relative;
  overflow: visible !important;
}

.carousel-container {
  width: 100%;
  overflow: visible !important;
  position: relative;
}

.carousel-track {
  display: flex;
  transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  gap: 30px;
  padding: 10px 0;
  will-change: transform;
}

/* Card Styles */
.collection-card {
  min-width: 300px;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
  transition: transform 0.3s ease;
  flex-shrink: 0;
  flex-grow: 0;
}

.collection-card:hover {
  transform: translateY(-8px);
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.12);
}

/* Image Container - Auto Rotate */
.image-rotate-container {
  position: relative;
  width: 100%;
  height: 280px;
  background: #f5f5f5;
  overflow: hidden;
}

.rotating-image {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0;
  transition: opacity 0.8s ease-in-out;
}

.rotating-image.active {
  opacity: 1;
}

/* Content */
.card-content {
  padding: 20px;
}

.collection-title {
  font-size: 1.25rem;
  font-weight: 700;
  color: #222;
  margin-bottom: 8px;
}

.collection-count {
  font-size: 0.95rem;
  color: #777;
  margin-bottom: 20px;
}

.shop-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #D4A574 0%, #B07F53 100%);
  color: white;
  border: none;
  border-radius: 10px;
  font-weight: 600;
  text-decoration: none;
  cursor: pointer;
  transition: all 0.3s ease;
}

.shop-button:hover {
  background: white;
  color: #D4A574;
  box-shadow: 0 0 0 2px #D4A574;
}

/* Navigation Buttons */
.carousel-nav {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-top: 30px;
}

.nav-button {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: white;
  border: 2px solid #eee;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  font-size: 20px;
  color: #333;
}

.nav-button:hover:not(:disabled) {
  background: #D4A574;
  color: white;
  border-color: #D4A574;
  transform: scale(1.1);
}

.nav-button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  transform: none !important;
}

/* Responsive */
@media (max-width: 768px) {
  .featured-collections-section {
    padding: 40px 15px;
  }
  
  .collection-card {
    min-width: 280px;
  }
  
  .image-rotate-container {
    height: 240px;
  }
  
  .carousel-track {
    gap: 20px;
  }
}

@media (max-width: 480px) {
  .collection-card {
    min-width: 260px;
  }
  
  .image-rotate-container {
    height: 220px;
  }
  
  .carousel-nav {
    margin-top: 20px;
  }
  
  .nav-button {
    width: 44px;
    height: 44px;
  }
}
</style>

<section class="featured-collections-section">
  <div class="featured-collections-header">
    <h2 class="featured-collections-title">{{ section.settings.title | default: "Shop By Collection" }}</h2>
    <p class="featured-collections-description">{{ section.settings.description | default: "Discover curated products for your unique hair journey" }}</p>
  </div>

  <div class="featured-collections-carousel">
    <div class="carousel-container">
      <div class="carousel-track" id="carouselTrack">
        {% for block in section.blocks %}
          {% assign collection = collections[block.settings.collection] %}
          {% if collection %}
            {% assign products = collection.products %}
            <div class="collection-card" data-collection-id="{{ collection.id }}">
              <div class="image-rotate-container" data-collection-index="{{ forloop.index0 }}">
                {% comment %} Collection Image as Fallback {% endcomment %}
                {% if collection.image %}
                  <img 
                    src="{{ collection.image | image_url: width: 600 }}"
                    alt="{{ collection.title | escape }}"
                    class="rotating-image active"
                    loading="lazy"
                    width="600"
                    height="400"
                  >
                {% endif %}
                
                {% comment %} Product Images for Rotation {% endcomment %}
                {% for product in products limit: 4 %}
                  {% if product.featured_image %}
                    <img 
                      src="{{ product.featured_image | image_url: width: 600 }}"
                      alt="{{ product.title | escape }}"
                      class="rotating-image"
                      loading="lazy"
                      width="600"
                      height="400"
                      data-index="{{ forloop.index }}"
                    >
                  {% endif %}
                {% endfor %}
                
                {% comment %} Fallback if no images {% endcomment %}
                {% unless collection.image or products.first.featured_image %}
                  <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #f0f0f0, #e0e0e0);">
                    <span style="color: #999; font-size: 1.1rem;">No Image</span>
                  </div>
                {% endunless %}
              </div>
              
              <div class="card-content">
                <h3 class="collection-title">{{ collection.title }}</h3>
                <p class="collection-count">{{ collection.products_count }} products</p>
                <a href="{{ collection.url }}" class="shop-button">
                  Shop Now
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8.781 8l-3.3-3.3.943-.943L10.667 8l-4.243 4.243-.943-.943 3.3-3.3z"/>
                  </svg>
                </a>
              </div>
            </div>
          {% endif %}
        {% endfor %}
      </div>
    </div>
    
    {% if section.blocks.size > 1 %}
      <div class="carousel-nav">
        <button class="nav-button prev-button" id="prevButton" aria-label="Previous collections">
          ←
        </button>
        <button class="nav-button next-button" id="nextButton" aria-label="Next collections">
          →
        </button>
      </div>
    {% endif %}
  </div>
</section>

<script defer>
document.addEventListener('DOMContentLoaded', function() {
  // Carousel Elements
  const carouselTrack = document.getElementById('carouselTrack');
  const prevButton = document.getElementById('prevButton');
  const nextButton = document.getElementById('nextButton');
  const cards = Array.from(document.querySelectorAll('.collection-card'));
  if (!carouselTrack || cards.length === 0) return;

  // Settings
  const GAP = 30; // must match your CSS .carousel-track gap
  const AUTOPLAY_MS = 2000; // auto-advance every 2000ms (2s)
  let currentSlide = 0;
  let autoplayTimer = null;
  let isHovered = false;
  let isFocused = false;

  // Utility: compute sizes dynamically
  function getCardWidth() {
    // get bounding width of first card (includes padding/border)
    return (cards[0] ? cards[0].getBoundingClientRect().width : 0) + GAP;
  }
  function getMaxVisible() {
    const viewportWidth = carouselTrack.parentElement.clientWidth;
    const cardW = getCardWidth();
    return Math.max(1, Math.floor(viewportWidth / cardW));
  }
  function getMaxScroll() {
    return Math.max(0, cards.length - getMaxVisible());
  }

  // Update carousel position using currentSlide
  function updateCarouselPosition(animate = true) {
    const cardW = getCardWidth();
    const translateX = currentSlide * cardW;
    if (!animate) {
      carouselTrack.style.transition = 'none';
    } else {
      carouselTrack.style.transition = 'transform 0.5s ease-in-out';
    }
    carouselTrack.style.transform = `translateX(-${translateX}px)`;

    // restore transition after disabling it briefly
    if (!animate) {
      // force reflow then restore
      void carouselTrack.offsetWidth;
      carouselTrack.style.transition = 'transform 0.5s ease-in-out';
    }

    // Update button states (if exist)
    if (prevButton) prevButton.disabled = currentSlide === 0;
    if (nextButton) nextButton.disabled = currentSlide >= getMaxScroll();
  }

  // Next / Prev with dynamic bounds
  function nextSlide() {
    const maxScroll = getMaxScroll();
    if (currentSlide < maxScroll) {
      currentSlide = Math.min(maxScroll, currentSlide + 1);
    } else {
      // loop back to start for continuous feel
      currentSlide = 0;
    }
    updateCarouselPosition();
  }
  function prevSlide() {
    if (currentSlide > 0) {
      currentSlide = Math.max(0, currentSlide - 1);
    } else {
      // jump to end
      currentSlide = getMaxScroll();
    }
    updateCarouselPosition();
  }

  // Autoplay control
  function startAutoplay() {
    stopAutoplay();
    autoplayTimer = setInterval(() => {
      if (!isHovered && !isFocused) nextSlide();
    }, AUTOPLAY_MS);
  }
  function stopAutoplay() {
    if (autoplayTimer) {
      clearInterval(autoplayTimer);
      autoplayTimer = null;
    }
  }

  // Button listeners
  if (nextButton) nextButton.addEventListener('click', () => { nextSlide(); resetAutoplay(); });
  if (prevButton) prevButton.addEventListener('click', () => { prevSlide(); resetAutoplay(); });

  // Pause/resume helpers
  function resetAutoplay() {
    stopAutoplay();
    // small delay before restart to avoid immediate jump after manual nav
    setTimeout(() => startAutoplay(), 900);
  }

  // Pause on hover over the carousel viewport or when focusing any card
  const viewport = carouselTrack.parentElement;
  viewport.addEventListener('mouseenter', () => { isHovered = true; stopAutoplay(); });
  viewport.addEventListener('mouseleave', () => { isHovered = false; startAutoplay(); });

  cards.forEach(card => {
    card.addEventListener('focusin', () => { isFocused = true; stopAutoplay(); });
    card.addEventListener('focusout', () => { isFocused = false; startAutoplay(); });
  });

  // Touch support (keep simple: allow manual swipe gestures on the track)
  let touchStartX = 0;
  let touchCurrentX = 0;
  let isTouching = false;
  carouselTrack.addEventListener('touchstart', (e) => {
    if (!e.touches || e.touches.length === 0) return;
    isTouching = true;
    touchStartX = e.touches[0].clientX;
    touchCurrentX = touchStartX;
    stopAutoplay();
    carouselTrack.style.transition = 'none';
  }, { passive: true });

  carouselTrack.addEventListener('touchmove', (e) => {
    if (!isTouching) return;
    touchCurrentX = e.touches[0].clientX;
    const dx = touchStartX - touchCurrentX;
    // translate visually during swipe
    const previewTranslate = (currentSlide * getCardWidth()) + dx;
    carouselTrack.style.transform = `translateX(-${previewTranslate}px)`;
  }, { passive: true });

  carouselTrack.addEventListener('touchend', (e) => {
    if (!isTouching) return;
    isTouching = false;
    const diff = touchStartX - touchCurrentX;
    const threshold = 50; // px
    // restore transition
    carouselTrack.style.transition = 'transform 0.5s ease-in-out';
    if (Math.abs(diff) > threshold) {
      if (diff > 0) nextSlide(); else prevSlide();
    } else {
      // small swipe: snap back
      updateCarouselPosition();
    }
    setTimeout(() => startAutoplay(), 600);
  });

  // Keyboard controls
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight') { nextSlide(); resetAutoplay(); }
    if (e.key === 'ArrowLeft') { prevSlide(); resetAutoplay(); }
  });

  // Recalculate on resize and keep currentSlide valid
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      // clamp currentSlide to available max after resize
      const max = getMaxScroll();
      if (currentSlide > max) currentSlide = max;
      updateCarouselPosition(false); // jump without animation to new clamped pos
    }, 120);
  });

  // --- Inner image rotation (per-card) --- //
  // We make rotation robust, store intervals, pause on hover of that image container
  const rotateContainers = Array.from(document.querySelectorAll('.image-rotate-container'));
  const rotateState = new Map();

  rotateContainers.forEach(container => {
    const imgs = Array.from(container.querySelectorAll('.rotating-image'));
    if (imgs.length <= 1) return;
    // ensure first image visible
    imgs.forEach((im, i) => im.classList.toggle('active', i === 0));
    let idx = 0;
    function rotateOnce() {
      imgs[idx].classList.remove('active');
      idx = (idx + 1) % imgs.length;
      imgs[idx].classList.add('active');
    }
    // start interval
    const id = setInterval(rotateOnce, 6000);
    rotateState.set(container, { intervalId: id, rotateOnce });

    // pause on hover/focus
    container.addEventListener('mouseenter', () => {
      const s = rotateState.get(container);
      if (s && s.intervalId) { clearInterval(s.intervalId); s.intervalId = null; rotateState.set(container, s); }
    });
    container.addEventListener('mouseleave', () => {
      const s = rotateState.get(container);
      if (s && !s.intervalId) { s.intervalId = setInterval(s.rotateOnce, 2000); rotateState.set(container, s); }
    });

    // accessibility: pause when focused inside
    container.addEventListener('focusin', () => {
      const s = rotateState.get(container);
      if (s && s.intervalId) { clearInterval(s.intervalId); s.intervalId = null; rotateState.set(container, s); }
    });
    container.addEventListener('focusout', () => {
      const s = rotateState.get(container);
      if (s && !s.intervalId) { s.intervalId = setInterval(s.rotateOnce, 2000); rotateState.set(container, s); }
    });
  });

  // Init: set starting sizes and start autoplay
  // Wait a tick in case fonts/images affect sizing
  setTimeout(() => {
    updateCarouselPosition(false);
    startAutoplay();
  }, 120);
});
</script>


{% schema %}
{
  "name": "Featured Collections",
  "max_blocks": 10,
  "settings": [
    {
      "type": "text",
      "id": "title",
      "label": "Title",
      "default": "Shop By Collection"
    },
    {
      "type": "textarea",
      "id": "description",
      "label": "Description",
      "default": "Discover curated products for your unique hair journey"
    }
  ],
  "blocks": [
    {
      "type": "collection",
      "name": "Collection",
      "settings": [
        {
          "type": "collection",
          "id": "collection",
          "label": "Select collection"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "Featured Collections",
      "category": "Collections",
      "blocks": [
        {
          "type": "collection"
        },
        {
          "type": "collection"
        },
        {
          "type": "collection"
        },
        {
          "type": "collection"
        }
      ]
    }
  ]
}
{% endschema %}